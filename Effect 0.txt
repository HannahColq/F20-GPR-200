// using color = vec3;

#define colorRGB	vec3
#define colorRGBA	vec4

/* Notes/Stuff from Class
vec4 myEffect0(in vec2 fragCoord, in vec2 resolution)
{
    //return vec4(1.0, 0.0, 0.0, 1.0);
    
    // R -> horiz
    // G -> vert
    // B
    // A
    //return vec4(fragCoord, 0.0, 1.0);
    
    //final: red-green gradient
    vec2 uv = fragCoord / resolution;
    return vec4(uv, 0.0, 1.0);
    
    //Alternate way to do the above return
    //vec3 color = vec3(uv, 0.25);
    //float alpha 1.0;
    //return vec4(color, alpha)
        
    //How arrays work
    //float array[6] = float[6](1.0, 2.0, 3.0, 4.0, 5.0, 6.0);
    //color[0] = 1.0; // color.x = 1.0;
    //color.r = 1.0;  // color.x = 1.0;
}

From mainImage
//R, G, B, A
    //fragColor = vec4(1.0, 1.0, 1.0, 1.0);

// Normalized pixel coordinates (from 0 to 1)
    // vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Output to screen
    //fragColor = vec4(col,1.0);

*/


//Effect 0 This effect courtesy of Professor Buckstein in class
vec4 redGreenGradient(in vec2 fragCoord, in vec2 resolution)
{
    //Calculates and returns values based on pixel location. Sets Red and Green Value based on those calculations.
    vec2 uv = fragCoord / resolution;
    return vec4(uv, 0.0, 1.0);
}




void mainImage( out vec4 fragColor, in vec2 fragCoord )
{    
    fragColor = redGreenGradient(fragCoord, iResolution.xy);   
    
}