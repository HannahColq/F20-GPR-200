/*   ----NOTES/CODE FROM CLASS----
// dummy function
vec4 add(in int index)
{
 	return vec4(float(index));   
}

float pow64(float x)
{
 	x *= x;
    x *= x;	
    x *= x;	
    x *= x;	
    x *= x;	
    x *= x;	
    return x;
}

float lenSq(in vec2 x)
{
    return dot(x,x);
}
float lenSq(in vec3 x)
{
    return dot(x,x);
}
float lenSq(in vec4 x)
{
    return dot(x,x);
}

    // EFFICIENCY TIPS
    float a = fragCoord.x + 2.0;		// 3.0: parallel 
    
    float b = a >= 0.0 ? +a : -a;
    
    if (a < 50.0)						// parallel
    {
        // do stuff
    }
    else
    {
        //do stuff
    }
    
    vec4 result = vec4(0.0);
    int numSamples = 8;
    int i = numSamples;
    // for (i = 0; i < numSamples; i++)
    //for (i = numSamples - 1; i >= 0; --i)
    //{
    // 	result += vec4(float(i));   
    //}
    result += add(--i);
    result += add(--i);
    result += add(--i);
    result += add(--i);
    result += add(--i);
    
    // ***EXAMPLES
    //float aSq = a*a;			// pow(a, 2.0) NO!
    //float aCu = aSq * a;		// a * a * a also works
    //float a4 = aSq * aSq;
   	//a *= a;	// square a
   	//a *= a;	//original a^4
   	//a *= a;	//original a^8
    // how do I make it look prettier?
    a = pow64(a);
    
    float len2 = lenSq(rayDirection);
      	//dot(rayDirection, rayDirection);
        		//    rayDirection.x * rayDirection.x
        		//  + rayDirection.y * rayDirection.y
        		//  + rayDirection.z * rayDirection.z;
        //length(rayDirection) * length(rayDirection)   No. One length already calculates the square root which is what we want :/;
    
    //vec2 s = vec2(rayDirection.x, rayDirection.y);
    //vec2 s = rayDirection.xy;
    
    //vec2 s = vec2(rayDirection.y, rayDirection.x);
    vec2 s = rayDirection.yx;	//swizzling
    
    // more swizzling
    vec3 s3 = rayDirection.yyz;	// with dups: not writable
    rayDirection.yzx = vec3(1.0, 2.0, 3.0);	// writable
    rayDirection.yxz = rayDirection.zxy;
    vec4 s4 = len2.xxxx;
    
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    //vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Output to screen
    //fragColor = vec4(col,1.0);

	if (__VERSION__ == 300)
        fragColor = vec4(1.0);
    
}

/*
#version 300 es

// inputs (later)
// uniforms (see above)

// output
layout (location = 0) out vec4 rtFragColor;

/// shadertoy specific
void mainImage(out vec4 fragColor, in vec2 fragCoord);

void main()
{
	// shadertoy
	mainImage(rtFragColor, gl_FragCoord.xy);
}
*/




//The following code courtesy of Daniel Buckstein
// calcViewport: calculate the viewing plane (viewport) coordinate
//    viewport:       output viewing plane coordinate
//    ndc:            output normalized device coordinate
//    uv:             output screen-space coordinate
//    aspect:         output aspect ratio of screen
//    resolutionInv:  output reciprocal of resolution
//    viewportHeight: input height of viewing plane
//    fragCoord:      input coordinate of current fragment (in pixels)
//    resolution:     input resolution of screen (in pixels)
void calcViewport(out vec2 viewport, out vec2 ndc, out vec2 uv,
                  out float aspect, out vec2 resolutionInv,
                  in float viewportHeight, in vec2 fragCoord, in vec2 resolution)
{
    // inverse (reciprocal) resolution = 1 / resolution
    resolutionInv = 1.0 / resolution;
    
    // aspect ratio = screen width / screen height
    aspect = resolution.x * resolutionInv.y;

    // uv = screen-space coordinate = [0, 1) = coord / resolution
    uv = fragCoord * resolutionInv;

    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1
    ndc = uv * 2.0 - 1.0;

    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2)
    viewport = ndc * (vec2(aspect, 1.0) * (viewportHeight * 0.5));
}

//The following code courtesy of Daniel Buckstein
// calcRay: calculate the ray direction and origin for the current pixel
//    rayDirection: output direction of ray from origin
//    rayOrigin:    output origin point of ray
//    viewport:     input viewing plane coordinate (use above function to calculate)
//    focalLength:  input distance to viewing plane
void calcRay(out vec4 rayDirection, out vec4 rayOrigin,
             in vec2 viewport, in float focalLength)
{
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    rayOrigin = vec4(0.0, 0.0, 0.0, 1.0);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    rayDirection = vec4(viewport.x, viewport.y, -focalLength, 0.0);
}

//hitSphere: calculate if the ray hits the sphere
//Code based on Peter Shirley's Ray Tracing in One Weekend 
//https://raytracing.github.io/books/RayTracingInOneWeekend.html#rays,asimplecamera,andbackground
float hitSphere(in vec3 center, in float radius, in vec4 rayDirection, in vec4 rayOrigin)
{
    //Math to calculate if the sphere will be hit by the ray
 	vec3 oc = vec3(rayOrigin.xyz - center);
    float a = dot(rayDirection, rayDirection);
    float b = dot(oc, rayDirection.xyz);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - a * c;
    if (discriminant < 0.0)
    {
     	return -1.0;   
    }
    else
    {
     	return (-b - sqrt(discriminant))  /  a;   
    }
}

//Base for this code courtesy of Daniel Buckstein
//Code based on Peter Shirley's Ray Tracing in One Weekend 
//https://raytracing.github.io/books/RayTracingInOneWeekend.html#rays,asimplecamera,andbackground
// calcColor: calculate the color of a pixel given a ray
//    rayDirection: input ray direction
//    rayOrigin:    input ray origin
vec4 calcColor(in vec4 rayDirection, in vec4 rayOrigin)
{   
    
    //NOTE I recognize that I basically don't do 6.3-6.7 stuff. I just couldn't figure out how to make it work for 
    //the life of me but doing the way I did got me the same result so I went with it cause it was late at night
    
    //Variable t based off of the ray hits the sphere
    float t = hitSphere(vec3(0.0, 0.0, -1.0), 0.5, rayDirection, rayOrigin);
    float w = hitSphere(vec3(0.0, -100.5, -1.0), 100.0, rayDirection, rayOrigin);
	//If ray hits sphere return color based on ray direction and origin   
    if (t > 0.0)
    {
     	vec3 n = vec3((rayOrigin.xyz + t * rayDirection.xyz) - vec3(0.0, 0.0, -1.0));
        vec3 rgbColor = vec3(0.5 * vec3(n.x + 1.0, n.y + 1.0, n.z + 1.0));
        return vec4(rgbColor, 1.0);
    }
    
    if (w > 0.0)
    {
     	//vec3 n = vec3((rayOrigin.xyz + t * rayDirection.xyz) - vec3(0.0, 0.0, -1.0));
        //vec3 rgbColor = vec3(0.5 * vec3(n.x + 1.0, n.y + 1.0, n.z + 1.0));
        vec3 worldColor = vec3(0.49412, 1.0, 0.49804);
        return vec4(worldColor, 1.0);
    }
    
    //Changes t based on ray direction for when the ray doesn't hit the sphere                         
    t = 0.5 * rayDirection.y + 1.0;                
    //rgb values for color based off of t
    vec3 rgbColor = (1.0-t) * vec3(1.0) + t * vec3(0.5, 0.7, 1.0);
    //returns the rgb values and 1.0 for the alpha
    return vec4(rgbColor, 1.0);
}

//Base of mainImage courtesy of Daniel Buckstein
// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // viewing plane (viewport) info
    vec2 viewport, ndc, uv, resolutionInv;
    float aspect;
    const float viewportHeight = 2.0, focalLength = 1.0;

    // ray
    vec4 rayDirection, rayOrigin;

    // setup
    calcViewport(viewport, ndc, uv, aspect, resolutionInv,
                 viewportHeight, fragCoord, iResolution.xy);
    calcRay(rayDirection, rayOrigin,
            viewport, focalLength);

    // color
    fragColor = calcColor(rayDirection, rayOrigin);
}