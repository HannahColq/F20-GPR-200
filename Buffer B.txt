//Some code based on code provided previously by Daniel Buckstein

//Sphere Data Structure
struct sphere
{
    vec4 center;
    float radius;
};

//Initialize Sphere
void initSphere(out sphere sphere, 
                in vec3 center, in float radius)
{
    sphere.center = asPoint(center);
    sphere.radius = radius;
}

//Point Light Data Structure
struct pointLight
{
  	vec4 center;
    vec3 color;
    float intensity;
};
    
//Initialize Light
void initLight(out pointLight light, in vec3 center, in vec3 color, in float intensity)
{
    light.center = asPoint(center);
    light.color = color;
    light.intensity = intensity;
}

//Calculate output
vec4 calcColor(in vec4 rayDirection, in vec4 rayOrigin, in sCoord uv)
{	
    //Sphere Setup
    //float radius = max(0.5, something to do with sound);
    float radius = 0.5;
    sphere sphere;
    initSphere(sphere, vec3(0.0, 0.0, -4.0), radius);
    
    //Light Setup
    pointLight light;
    initLight(light, vec3(-2.0, -3.0, -6.0), vec3(1.0, 1.0, 1.0), 8.0);

    //Initialize values needed
    vec3 dp;
    dp.xy = rayDirection.xy - sphere.center.xy;
    float lSq = lengthSq(dp.xy);
    float rSq = sphere.radius * sphere.radius;
    
    //Display Sphere
    if (lSq <= rSq)
    {
   		dp.z = rSq - lSq;
    	vec3 position = sphere.center.xyz + vec3(dp.x, dp.y, sqrt(dp.z));
    	vec3 normal = (position - sphere.center.xyz) / sphere.radius;
    
        //Light normal vector
 	 	vec3 lightNormal = normalize(position - light.center.xyz);
        //Distance from light to surface
  		float lightDist = distance(lightNormal, position);
    	//Diffuse Coefficient
    	float diffuseCoeff = max(0.0, dot(normal, lightNormal));
        
    	//Attenuation
    	float attenuation = 1.0 / (1.0 + (lightDist / light.intensity) + ((lightDist * lightDist) / (light.intensity * light.intensity)));
    	//Diffuse Intensity
    	float diffuseIntensity = diffuseCoeff * attenuation;
    
        //View vector normal
        vec3 viewVec = normalize(rayOrigin.xyz - position);
        //Reflected light vector
        vec3 refLight = reflect(-lightNormal, normal);
        //Specular Coefficient
        float specCoeff = max(0.0, dot(viewVec, refLight));
        //return vec4(specCoeff, specCoeff, specCoeff, 1.0);
        //Highlight Exponent
        float hlExponent = 8.0;
        //Specular Intensity
        float specularIntensity = pow(specCoeff, hlExponent);
       	
        //Final Color
        float globalAmbient = 0.5;
        vec3 globalAmbColor = vec3(1.0, 0.0, 0.25);   // CHANGE BASED ON SOUND!!!!!!!!!
        //Specular Reflection Color
        vec3 specColor = vec3(1.0);
        vec3 phColor = globalAmbient * globalAmbColor + (diffuseIntensity * (1.0) + specularIntensity * specColor) * light.color;
        return vec4(phColor, 1.0);
    }
    
    // Background
	return texture(iChannel0, uv);
    return vec4(1.0);
}

void mainImage(out color4 fragColor, in sCoord fragCoord)
{
    // setup
    // test UV for input image
    sCoord uv = fragCoord / iChannelResolution[0].xy;
    
   	// viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // viewport info
    sViewport vp;

    // ray
    sRay ray;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);
    
    fragColor = calcColor(ray.direction, ray.origin, uv);
}
